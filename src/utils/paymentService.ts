import { OrderService } from './orderService';
import { SepayService } from './sepayService';
import { TelegramNotificationService } from './telegramNotificationService';

interface PaymentData {
  orderId: string;
  paymentMethod: 'CASH' | 'BANK_TRANSFER';
  amount: number;
  tableCode: string;
  customerPhone: string;
  timestamp?: string;
}

interface TelegramMessage {
  chat_id: string;
  text: string;
  parse_mode?: 'HTML' | 'Markdown';
  reply_markup?: {
    inline_keyboard: Array<Array<{
      text: string;
      callback_data: string;
    }>>;
  };
}

const TELEGRAM_BOT_TOKEN = '7227042614:AAGeG3EZqSFVysFA-UU8mCw6o76UJrbCtJE';
const TELEGRAM_CHAT_ID = '-4852894219'; // Order Menu group ID
const WEBHOOK_SERVER_URL = 'http://localhost:3001';

export class PaymentService {
  // G·ª≠i th√¥ng tin thanh to√°n v·ªÅ webhook server v√† telegram bot
  static async processPayment(paymentData: PaymentData): Promise<{ success: boolean; message?: string }> {
    try {
      console.log('üîÑ Processing payment:', paymentData);
      
      // 1. L∆∞u th√¥ng tin thanh to√°n v√†o database
      const orderUpdateSuccess = await this.updateOrderPaymentInfo(paymentData);
      if (!orderUpdateSuccess) {
        throw new Error('Failed to update order payment information');
      }
      
      // 2. Log th√¥ng tin thanh to√°n chuy·ªÉn kho·∫£n (webhook ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh t·ª± ƒë·ªông)
      if (paymentData.paymentMethod === 'BANK_TRANSFER') {
        console.log('üîó Bank transfer payment initiated for order:', paymentData.orderId);
        console.log('üí∞ Amount:', paymentData.amount);
        console.log('üì± Webhook URL configured:', import.meta.env.VITE_SEPAY_WEBHOOK_URL);
      }
      
      // 3. G·ª≠i th√¥ng b√°o ƒë·∫øn Telegram bot
      const telegramSuccess = await this.sendTelegramNotification(paymentData);
      if (!telegramSuccess) {
        console.warn('‚ö†Ô∏è Failed to send Telegram notification, but payment was processed');
      }
      
      // 4. G·ª≠i th√¥ng tin ƒë·∫øn webhook server (n·∫øu c√≥)
      await this.notifyWebhookServer(paymentData);
      
      console.log('‚úÖ Payment processed successfully');
      return { success: true, message: 'Payment processed successfully' };
      
    } catch (error) {
      console.error('‚ùå Error processing payment:', error);
      return { success: false, message: error instanceof Error ? error.message : 'Unknown error' };
    }
  }
  
  // C·∫≠p nh·∫≠t th√¥ng tin thanh to√°n trong database
  private static async updateOrderPaymentInfo(paymentData: PaymentData): Promise<boolean> {
    try {
      // C·∫≠p nh·∫≠t order v·ªõi th√¥ng tin thanh to√°n
      const updateData = {
        payment_method: paymentData.paymentMethod,
        payment_status: 'pending',
        payment_amount: paymentData.amount,
        updated_at: new Date().toISOString()
      };
      
      const success = await OrderService.updateOrder(paymentData.orderId, updateData);
      console.log(`üíæ Database update ${success ? 'successful' : 'failed'} for order ${paymentData.orderId}`);
      
      return success;
    } catch (error) {
      console.error('‚ùå Error updating order payment info:', error);
      return false;
    }
  }
  
  // G·ª≠i th√¥ng b√°o ƒë·∫øn Telegram bot
  private static async sendTelegramNotification(paymentData: PaymentData): Promise<boolean> {
    try {
      const message = this.formatTelegramMessage(paymentData);
      
      const response = await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(message)
      });
      
      const result = await response.json();
      
      if (result.ok) {
        console.log('üì± Telegram notification sent successfully');
        return true;
      } else {
        console.error('‚ùå Telegram API error:', result);
        return false;
      }
    } catch (error) {
      console.error('‚ùå Error sending Telegram notification:', error);
      return false;
    }
  }
  
  // Format tin nh·∫Øn Telegram
  private static formatTelegramMessage(paymentData: PaymentData): TelegramMessage {
    const { orderId, paymentMethod, amount, tableCode, customerPhone } = paymentData;
    const timestamp = new Date().toLocaleString('vi-VN');
    
    const paymentMethodText = paymentMethod === 'CASH' ? 'üíµ Thanh to√°n ti·ªÅn m·∫∑t' : 'üè¶ Thanh to√°n chuy·ªÉn kho·∫£n';
    const amountFormatted = new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND'
    }).format(amount);
    
    const messageText = `üîî <b>ƒê∆†N H√ÄNG M·ªöI - TH√îNG TIN THANH TO√ÅN</b>\n\n` +
      `üìã <b>M√£ ƒë∆°n h√†ng:</b> ${orderId}\n` +
      `üè∑Ô∏è <b>B√†n s·ªë:</b> ${tableCode}\n` +
      `üìû <b>S·ªë ƒëi·ªán tho·∫°i:</b> ${customerPhone}\n` +
      `üí∞ <b>T·ªïng ti·ªÅn:</b> ${amountFormatted}\n` +
      `üí≥ <b>Ph∆∞∆°ng th·ª©c:</b> ${paymentMethodText}\n` +
      `‚è∞ <b>Th·ªùi gian:</b> ${timestamp}\n\n`;
    
    if (paymentMethod === 'CASH') {
      return {
        chat_id: TELEGRAM_CHAT_ID,
        text: messageText + `‚úÖ <i>Kh√°ch h√†ng s·∫Ω thanh to√°n ti·ªÅn m·∫∑t khi nh·∫≠n h√†ng</i>`,
        parse_mode: 'HTML',
        reply_markup: {
          inline_keyboard: [[
            {
              text: '‚úÖ X√°c nh·∫≠n ƒë∆°n h√†ng',
              callback_data: `confirm_${orderId}`
            },
            {
              text: '‚ùå T·ª´ ch·ªëi',
              callback_data: `reject_${orderId}`
            }
          ]]
        }
      };
    } else {
      return {
        chat_id: TELEGRAM_CHAT_ID,
        text: messageText + `‚è≥ <i>ƒêang ch·ªù kh√°ch h√†ng chuy·ªÉn kho·∫£n. Vui l√≤ng ki·ªÉm tra t√†i kho·∫£n ng√¢n h√†ng.</i>`,
        parse_mode: 'HTML',
        reply_markup: {
          inline_keyboard: [[
            {
              text: '‚úÖ ƒê√£ nh·∫≠n ti·ªÅn - X√°c nh·∫≠n',
              callback_data: `confirm_${orderId}`
            },
            {
              text: '‚ùå Ch∆∞a nh·∫≠n ti·ªÅn - T·ª´ ch·ªëi',
              callback_data: `reject_${orderId}`
            }
          ]]
        }
      };
    }
  }
  
  // Th√¥ng b√°o ƒë·∫øn webhook server (optional)
  private static async notifyWebhookServer(paymentData: PaymentData): Promise<void> {
    // Log payment information instead of calling external webhook server
    console.log('üìã Payment processed:', {
      orderId: paymentData.orderId,
      method: paymentData.paymentMethod,
      amount: paymentData.amount,
      table: paymentData.tableCode,
      timestamp: new Date().toISOString()
    });
    console.log('‚úÖ Payment data logged successfully');
  }
  
  // Ki·ªÉm tra tr·∫°ng th√°i thanh to√°n
  static async checkPaymentStatus(orderId: string): Promise<{
    status: 'pending' | 'confirmed' | 'rejected' | null;
    timestamp?: string;
  }> {
    try {
      // Ki·ªÉm tra t·ª´ webhook server tr∆∞·ªõc
      const response = await fetch(`${WEBHOOK_SERVER_URL}/api/order-status/${orderId}`);
      if (response.ok) {
        const data = await response.json();
        if (data.success) {
          return {
            status: data.status,
            timestamp: data.timestamp
          };
        }
      }
      
      // Fallback: ki·ªÉm tra t·ª´ database
      const order = await OrderService.getOrderById(orderId);
      if (order) {
        return {
          status: order.status || 'pending',
          timestamp: order.updated_at || order.created_at
        };
      }
      
      return { status: null };
    } catch (error) {
      console.error('‚ùå Error checking payment status:', error);
      return { status: null };
    }
  }
  
  // X·ª≠ l√Ω webhook t·ª´ Sepay
  static async handleSepayWebhook(webhookData: any): Promise<{ success: boolean; message: string }> {
    try {
      console.log('üîÑ Processing Sepay webhook:', webhookData);
      
      // X√°c th·ª±c webhook t·ª´ Sepay
      const isValid = SepayService.verifyWebhook(webhookData);
      if (!isValid) {
        return { success: false, message: 'Invalid webhook signature' };
      }

      // T√¨m ƒë∆°n h√†ng d·ª±a tr√™n reference code
      const orderId = SepayService.extractOrderIdFromWebhook(webhookData);
      if (!orderId) {
        return { success: false, message: 'Order ID not found in webhook data' };
      }

      // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng
      const updateData = {
        payment_status: 'confirmed',
        status: 'confirmed',
        updated_at: new Date().toISOString()
      };
      
      const updateResult = await OrderService.updateOrder(orderId, updateData);
      if (!updateResult) {
        return { success: false, message: 'Failed to update order status' };
      }

      // L·∫•y th√¥ng tin ƒë∆°n h√†ng ƒë·ªÉ g·ª≠i th√¥ng b√°o
      const order = await OrderService.getOrderById(orderId);
      if (order) {
        // T·∫°o d·ªØ li·ªáu thanh to√°n ƒë·ªÉ g·ª≠i th√¥ng b√°o
        const paymentData: PaymentData = {
          orderId: order.id,
          paymentMethod: 'BANK_TRANSFER',
          amount: order.total_amount,
          tableCode: order.table_code,
          customerPhone: order.customer_phone,
          timestamp: new Date().toISOString()
        };
        
        // G·ª≠i th√¥ng b√°o Telegram v·ªÅ thanh to√°n th√†nh c√¥ng
        await this.sendTelegramPaymentConfirmation(paymentData);
        
        // G·ª≠i th√¥ng b√°o bi·∫øn ƒë·ªông s·ªë d∆∞ t·ª´ ng√¢n h√†ng
        await TelegramNotificationService.sendBalanceNotification({
          transactionId: webhookData.id || 'UNKNOWN',
          accountNumber: webhookData.accountNumber || webhookData.bankAccount || 'UNKNOWN',
          amount: webhookData.transferAmount || webhookData.amountIn || 0,
          content: webhookData.content || 'Thanh to√°n ƒë∆°n h√†ng',
          transactionDate: webhookData.transactionDate || new Date().toISOString(),
          bankName: webhookData.bankName || 'Ng√¢n h√†ng',
          transferType: 'in',
          orderId: order.id
        });
      }

      console.log('‚úÖ Payment confirmed for order:', orderId);
      return { success: true, message: 'Payment processed successfully' };
    } catch (error) {
      console.error('‚ùå Error processing Sepay webhook:', error);
      return { 
        success: false, 
        message: error instanceof Error ? error.message : 'Unknown error' 
      };
    }
  }
  
  // G·ª≠i th√¥ng b√°o Telegram khi thanh to√°n ƒë∆∞·ª£c x√°c nh·∫≠n
  private static async sendTelegramPaymentConfirmation(paymentData: PaymentData): Promise<void> {
    try {
      const { orderId, amount, tableCode, customerPhone } = paymentData;
      const timestamp = new Date().toLocaleString('vi-VN');
      
      const amountFormatted = new Intl.NumberFormat('vi-VN', {
        style: 'currency',
        currency: 'VND'
      }).format(amount);
      
      const messageText = `‚úÖ <b>THANH TO√ÅN TH√ÄNH C√îNG</b>\n\n` +
        `üìã <b>M√£ ƒë∆°n h√†ng:</b> ${orderId}\n` +
        `üè∑Ô∏è <b>B√†n s·ªë:</b> ${tableCode}\n` +
        `üìû <b>S·ªë ƒëi·ªán tho·∫°i:</b> ${customerPhone}\n` +
        `üí∞ <b>S·ªë ti·ªÅn:</b> ${amountFormatted}\n` +
        `üè¶ <b>Ph∆∞∆°ng th·ª©c:</b> Chuy·ªÉn kho·∫£n ng√¢n h√†ng\n` +
        `‚è∞ <b>Th·ªùi gian:</b> ${timestamp}\n\n` +
        `üéâ <i>ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c thanh to√°n th√†nh c√¥ng qua chuy·ªÉn kho·∫£n!</i>`;
      
      const message: TelegramMessage = {
        chat_id: TELEGRAM_CHAT_ID,
        text: messageText,
        parse_mode: 'HTML',
        reply_markup: {
          inline_keyboard: [[
            {
              text: 'üç≥ B·∫Øt ƒë·∫ßu ch·∫ø bi·∫øn',
              callback_data: `start_cooking_${orderId}`
            },
            {
              text: 'üìã Xem chi ti·∫øt',
              callback_data: `view_details_${orderId}`
            }
          ]]
        }
      };
      
      const response = await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(message)
      });
      
      if (response.ok) {
        console.log('üì± Payment confirmation sent to Telegram');
      } else {
        console.error('‚ùå Failed to send payment confirmation to Telegram');
      }
    } catch (error) {
      console.error('‚ùå Error sending payment confirmation:', error);
    }
  }
}